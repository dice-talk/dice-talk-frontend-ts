import { getFilteredRoomEvents, getPickEventsForRoom, RoomEventFromApi } from "@/api/EventApi";
import { getChatRoomInfo } from "@/api/ChatApi";
import { getChatMessages } from "@/api/historyApi";
import SideBar from "@/app/(tabs)/chat/SideBar";
import DaoSvg from "@/assets/images/dice/dao.svg";
import DoriSvg from "@/assets/images/dice/dori.svg";
import Hana from '@/assets/images/dice/hana.svg';
import NemoSvg from '@/assets/images/dice/nemo.svg';
import SezziSvg from "@/assets/images/dice/sezzi.svg";
import YukdaengSvg from "@/assets/images/dice/yukdaeng.svg";
import ChatHeader from "@/components/chat/ChatHeader";
import ChatInput from "@/components/chat/ChatInput";
import ChatMessageLeft from "@/components/chat/ChatMessageLeft";
import ChatMessageRight from "@/components/chat/ChatMessageRight";
import ChatProfile from "@/components/chat/ChatProfile";
import GptNotice from "@/components/chat/GptNotice";
import ReadingTag from "@/components/chat/ReadingTag";
import EnvelopeAnimation from "@/components/event/animation/EnvelopeAnimation";
import ResultFriendArrow from "@/components/event/diceFriends/ResultFriendArrow";
import LoveArrow from "@/components/event/heartSignal/LoveArrow";
import LoveArrowMatch, { ProfileInfo } from "@/components/event/heartSignal/LoveArrowMatch";
import LoveLetterSelect from "@/components/event/heartSignal/LoveLetterSelect";
import ResultLoveArrow from "@/components/event/heartSignal/ResultLoveArrow";
import UnmatchedModal from "@/components/event/heartSignal/UnmatchedModal";
import useChat from "@/utils/useChat";
import useAuthStore from "@/zustand/stores/authStore";
import useChatRoomStore, { ChatMessage, PageInfo } from "@/zustand/stores/ChatRoomStore";
import useHomeStore from "@/zustand/stores/HomeStore";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { BlurView } from 'expo-blur';
import { useLocalSearchParams, useRouter } from "expo-router";
import React, { useCallback, useEffect, useMemo, useRef, useState } from "react";
import { ActivityIndicator, Animated, Dimensions, Keyboard, KeyboardEvent, Modal, NativeScrollEvent, Platform, ScrollView, StyleSheet, Text, TouchableOpacity, View } from "react-native";
import { SvgProps } from "react-native-svg";

import {
  SECRET_MESSAGE_START_OFFSET, SECRET_MESSAGE_END_OFFSET,
  CUPID_INTERIM_END_OFFSET, CUPID_MAIN_EVENT_END_OFFSET,
  CHAT_ROOM_END_OFFSET
} from "@/constants/chatEventTimes";

const nicknameToSvgMap: Record<string, React.FC<SvgProps>> = {
  "ÌïúÍ∞ÄÎ°úÏö¥ ÌïòÎÇò": Hana, "Îëê ÏñºÍµ¥Ïùò Îß§Î†• ÎëêÎ¶¨": DoriSvg, "ÏÑ∏Ïπ®Ìïú ÏÑ∏Ï∞å": SezziSvg,
  "ÎÑ§Î™®ÏßÄÎßå Î∂ÄÎìúÎü¨Ïö¥ ÎÑ§Î™Ω": NemoSvg, "Îã®Ìò∏ÌïúÎç∞ Îã§Ï†ïÌïú Îã§Ïò§": DaoSvg, "Ïú°Í∞êÏ†ÅÏù∏ ÏßÅÍ∞êÌåå Ïú°Îï°": YukdaengSvg,
};

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');

const ChatRoom = () => {
  const router = useRouter();
  const { chatRoomId: chatRoomIdFromParams, themeId: themeIdFromParams } = useLocalSearchParams<{ chatRoomId?: string, themeId?: string }>();

  const { setChatRoomDetails, clearChatRoomDetails, prependPastChats } = useChatRoomStore((state) => state.actions);
  const chatPageInfo = useChatRoomStore((state) => state.chatPageInfo);
  const curThemeId = useHomeStore((state) => state.curThemeId as number | undefined) ?? 1;
  const themeName = useChatRoomStore((state) => state.themeName);
  const createdAt = useChatRoomStore((state) => state.createdAt);
  const currentChatRoomId = useChatRoomStore((state) => state.chatRoomId);
  
  const alertModalTitleColor = curThemeId === 2 ? "#5C5279" : "#A45C73";
  const alertModalConfirmButtonColor = curThemeId === 2 ? "#9FC9FF" : "#FFB6C1";
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const [showNotice, setShowNotice] = useState(true);
  const [scrollViewMarginTop, setScrollViewMarginTop] = useState(SCREEN_HEIGHT * 0.075);
  const [selectedProfile, setSelectedProfile] = useState<{ nickname: string, SvgComponent: React.FC<SvgProps> } | null>(null);
  const [showEnvelope, setShowEnvelope] = useState(false);
  const [showLoveLetterSelect, setShowLoveLetterSelect] = useState(false);
  const [showLoveArrow, setShowLoveArrow] = useState(false);
  const [showResultLoveArrow, setShowResultLoveArrow] = useState(false);
  const [showResultFriendArrow, setShowResultFriendArrow] = useState(false);
  const [showResultAlertModal, setShowResultAlertModal] = useState(false);
  const [showLoveArrowMatch, setShowLoveArrowMatch] = useState(false);
  const [isEnvelopeReadOnly, setIsEnvelopeReadOnly] = useState(false);
  const [readOnlyEnvelopeMessages, setReadOnlyEnvelopeMessages] = useState<string[]>([]);
  const [showUnmatchedModal, setShowUnmatchedModal] = useState(false);
  const [matchedPair, setMatchedPair] = useState<{ myProfile?: ProfileInfo; partnerProfile?: ProfileInfo } | null>(null); 
  const [fixedReadingTagAtMessageId, setFixedReadingTagAtMessageId] = useState<number | null>(null);

  const readingTagCalculatedForRoom = useRef<number | null>(null); // ReadingTag Í≥ÑÏÇ∞ Ïó¨Î∂Ä Ï∂îÏ†Å
  const [isLoadingPast, setIsLoadingPast] = useState(false);
  const prevContentHeight = useRef(0);
  const shouldMaintainScroll = useRef(false);

  const scrollViewRef = useRef<ScrollView>(null);
  const [keyboardOffset, setKeyboardOffset] = useState(0);

  const animatedKeyboardOffset = useRef(new Animated.Value(0)).current;
  const baseScrollViewMarginBottom = useMemo(() => SCREEN_HEIGHT * 0.07, []);
  const animatedScrollViewMarginBottom = useRef(new Animated.Value(baseScrollViewMarginBottom)).current;
  
  const [currentEventPhase, setCurrentEventPhase] = useState("LOADING");
  const [remainingSecondsForDisplay, setRemainingSecondsForDisplay] = useState(0);
  const [activeNoticeType, setActiveNoticeType] = useState<"SECRET_MESSAGE_START" | "SECRET_MESSAGE_RESULT" | "LOVE_ARROW_START" | "LOVE_ARROW_RESULT" | null>(null);

  const roomIdNum = chatRoomIdFromParams ? Number(chatRoomIdFromParams) : 0;
  const initialChats = useChatRoomStore((state) => state.chats);
  const { messages, sendMessage, newMessagesArrived, setNewMessagesArrived } = useChat(roomIdNum, initialChats);

  const loadPastMessages = useCallback(async () => {
    if (isLoadingPast || !chatPageInfo || chatPageInfo.page >= chatPageInfo.totalPages - 1) {
      return;
    }

    setIsLoadingPast(true);
    shouldMaintainScroll.current = true;

    try {
      const nextPageToFetch = chatPageInfo.page + 1;
      const response = await getChatMessages(roomIdNum, nextPageToFetch, 30);

      if (response.content && response.content.length > 0) {
        const pastMessages: ChatMessage[] = response.content.map((dto) => ({
          chatId: dto.chatId,
          message: dto.message,
          memberId: dto.memberId,
          nickname: dto.nickName || 'Ïïå Ïàò ÏóÜÎäî ÏÇ¨Ïö©Ïûê',
          createdAt: dto.createdAt,
        }));
        
        const newPageInfo: PageInfo = {
            page: response.number,
            size: response.size,
            totalElements: response.totalElements,
            totalPages: response.totalPages,
        };

        prependPastChats(pastMessages, newPageInfo);
      }
    } catch (error) {
      console.error("üö® Í≥ºÍ±∞ Î©îÏãúÏßÄ Î°úÎìú Ï§ë Ïò§Î•ò Î∞úÏÉù:", error);
    } finally {
      setIsLoadingPast(false);
    }
  }, [isLoadingPast, chatPageInfo, roomIdNum, prependPastChats]);

  useEffect(() => {
    // currentChatRoomIdÍ∞Ä Ïú†Ìö®ÌïòÍ≥†, Ìï¥Îãπ Î∞©Ïóê ÎåÄÌï¥ ReadingTagÍ∞Ä ÏïÑÏßÅ Í≥ÑÏÇ∞ÎêòÏßÄ ÏïäÏïòÎã§Î©¥ Ïã§Ìñâ
    if (currentChatRoomId && readingTagCalculatedForRoom.current !== currentChatRoomId) {
      const loadAndSetInitialReadingTagPosition = async () => {
        // Î©îÏãúÏßÄÍ∞Ä ÏïÑÏßÅ Î°úÎìúÎêòÏßÄ ÏïäÏïòÎã§Î©¥, Îã§Ïùå Î†åÎçîÎßÅ ÏÇ¨Ïù¥ÌÅ¥ÏùÑ Í∏∞Îã§Î¶ΩÎãàÎã§.
        if (messages.length === 0) {
          return;
        }

        try {
          const key = `lastReading_${currentChatRoomId}`;
          const idStr = await AsyncStorage.getItem(key);
          let lastReadMessageIdFromStorage: number | null = idStr !== null ? Number(idStr) : null;

          let tagMessageId: number | null = null;

          // Ï†ÄÏû•Îêú ÎßàÏßÄÎßâ ÏùΩÏùÄ Î©îÏãúÏßÄ IDÎ≥¥Îã§ ÌÅ∞ Ï≤´ Î≤àÏß∏ Î©îÏãúÏßÄÎ•º Ï∞æÏäµÎãàÎã§.
          const firstUnreadMessage = messages.find(msg => msg.chatId > (lastReadMessageIdFromStorage || 0));

          if (firstUnreadMessage) {
            tagMessageId = firstUnreadMessage.chatId;
            console.log(`[ReadingTag] ÏÉàÎ°úÏö¥ Î©îÏãúÏßÄ Î∞úÍ≤¨. Ï≤´ Î≤àÏß∏ ÏùΩÏßÄ ÏïäÏùÄ Î©îÏãúÏßÄ ID: ${tagMessageId}`);
          } else {
            tagMessageId = null;
            console.log(`[ReadingTag] ÏùΩÏßÄ ÏïäÏùÄ Î©îÏãúÏßÄ ÏóÜÏùå. ÌÉúÍ∑∏ ÌëúÏãú Ïïà Ìï®.`);
          }

          setFixedReadingTagAtMessageId(tagMessageId);
          setNewMessagesArrived(false); // ReadingTag Î°úÏßÅ Ï≤òÎ¶¨ ÌõÑ ÌîåÎûòÍ∑∏ Ï¥àÍ∏∞Ìôî

          // Ïù¥ Ï±ÑÌåÖÎ∞©Ïóê ÎåÄÌï¥ ReadingTag Í≥ÑÏÇ∞Ïù¥ ÏôÑÎ£åÎêòÏóàÏùåÏùÑ ÌëúÏãú
          readingTagCalculatedForRoom.current = currentChatRoomId;

        } catch (e) {
          console.error('‚ùå ÎßàÏßÄÎßâÏúºÎ°ú ÏùΩÏùÄ Î©îÏãúÏßÄ ID Î°úÎî© Ïã§Ìå®:', e);
          setFixedReadingTagAtMessageId(null);
          setNewMessagesArrived(false);
        }
      };
      loadAndSetInitialReadingTagPosition();
    }
  }, [currentChatRoomId, messages.length, setNewMessagesArrived]); // messages.lengthÎ•º ÏùòÏ°¥ÏÑ±ÏúºÎ°ú Ï∂îÍ∞ÄÌïòÏó¨ Ï¥àÍ∏∞ Î©îÏãúÏßÄ Î°úÎìú ÌõÑ Ïã§Ìñâ Î≥¥Ïû•

  useEffect(() => {
    return () => {
      const saveLastReadOnUnmount = async () => {
        if (messages && messages.length > 0 && currentChatRoomId) {
          const lastMessageInView = messages[messages.length - 1];
          if (lastMessageInView && lastMessageInView.chatId) {
            try {
              const key = `lastReading_${currentChatRoomId}`;
              await AsyncStorage.setItem(key, String(lastMessageInView.chatId));
            } catch (e) {
              console.error('‚ùå ÎßàÏßÄÎßâÏúºÎ°ú ÏùΩÏùÄ Î©îÏãúÏßÄ ID Ï†ÄÏû• Ïã§Ìå®:', e);
            }
          }
        }
      };
      saveLastReadOnUnmount();
    };
  }, [messages, currentChatRoomId]);

  useEffect(() => {
    if (scrollViewRef.current && (messages && messages.length > 0 || keyboardOffset > 0)) {
      scrollViewRef.current?.scrollToEnd({ animated: true });
    }
  }, [messages, keyboardOffset]);

  useEffect(() => {
    if (chatRoomIdFromParams) {
      const themeIdToSetInChatRoomStore = themeIdFromParams ? parseInt(themeIdFromParams) : (useChatRoomStore.getState().themeId || 1);
      setChatRoomDetails({ chatRoomId: Number(chatRoomIdFromParams), themeId: themeIdToSetInChatRoomStore });
    } else {
      console.warn("ChatRoom.tsx: chatRoomId not found in params.");
    }
  }, [chatRoomIdFromParams, themeIdFromParams, setChatRoomDetails]);

  useEffect(() => {
    if (showNotice) {
      setScrollViewMarginTop(SCREEN_HEIGHT * 0.12); 
    } else {
      setScrollViewMarginTop(SCREEN_HEIGHT * 0.075);
    }
  }, [showNotice]);

  useEffect(() => {
    if (!createdAt) {
      setCurrentEventPhase("ERROR");
      return;
    }

    let isoCreatedAt = createdAt.replace(' ', 'T');
    if (!isoCreatedAt.endsWith('Z') && !isoCreatedAt.match(/[+-]\d{2}:\d{2}$/)) {
      isoCreatedAt += 'Z';
    }
    const creationTimestamp = new Date(isoCreatedAt).getTime();

    if (isNaN(creationTimestamp)) {
      setCurrentEventPhase("ERROR");
      return;
    }

    const updateEventStateInChatRoom = () => {
      const currentTimestamp = Date.now();
      const elapsedSeconds = Math.floor((currentTimestamp - creationTimestamp) / 1000);

      let targetTimestamp = 0;
      let newPhase = "";
      let newActiveNoticeType: typeof activeNoticeType = null;

      if (elapsedSeconds < SECRET_MESSAGE_START_OFFSET) {
        targetTimestamp = creationTimestamp + SECRET_MESSAGE_START_OFFSET * 1000;
        newPhase = "PRE_SECRET";
        newActiveNoticeType = null;
      } else if (elapsedSeconds < SECRET_MESSAGE_END_OFFSET) {
        targetTimestamp = creationTimestamp + SECRET_MESSAGE_END_OFFSET * 1000;
        newPhase = "SECRET";
        newActiveNoticeType = "SECRET_MESSAGE_START";
      } else if (elapsedSeconds < CUPID_INTERIM_END_OFFSET) {
        targetTimestamp = creationTimestamp + CUPID_INTERIM_END_OFFSET * 1000;
        newPhase = "CUPID_INTERIM";
        newActiveNoticeType = "SECRET_MESSAGE_RESULT";
      } else if (elapsedSeconds < CUPID_MAIN_EVENT_END_OFFSET) {
        targetTimestamp = creationTimestamp + CUPID_MAIN_EVENT_END_OFFSET * 1000;
        newPhase = "CUPID_MAIN";
        newActiveNoticeType = "LOVE_ARROW_START"; 
      } else if (elapsedSeconds < CHAT_ROOM_END_OFFSET) {
        targetTimestamp = creationTimestamp + CHAT_ROOM_END_OFFSET * 1000;
        newPhase = "COUNTDOWN_TO_END";
        newActiveNoticeType = "LOVE_ARROW_RESULT"; 
      } else {
        targetTimestamp = currentTimestamp;
        newPhase = "POST_EVENT";
        newActiveNoticeType = null;
      }

      setRemainingSecondsForDisplay(Math.max(0, Math.floor((targetTimestamp - currentTimestamp) / 1000)));
      setCurrentEventPhase(newPhase);
      setActiveNoticeType(newActiveNoticeType);
    };

    updateEventStateInChatRoom();
    const intervalId = setInterval(updateEventStateInChatRoom, 1000);
    return () => clearInterval(intervalId);
  }, [createdAt]);

  useEffect(() => {
    const KEYBOARD_ANIMATION_DURATION = Platform.OS === 'ios' ? 250 : 10;

    const handleKeyboardDidShow = (e: KeyboardEvent) => {
      const keyboardHeight = e.endCoordinates.height;
      setKeyboardOffset(keyboardHeight);
      Animated.parallel([
        Animated.timing(animatedKeyboardOffset, { toValue: keyboardHeight, duration: KEYBOARD_ANIMATION_DURATION, useNativeDriver: false }),
        Animated.timing(animatedScrollViewMarginBottom, { toValue: baseScrollViewMarginBottom + keyboardHeight, duration: KEYBOARD_ANIMATION_DURATION, useNativeDriver: false }),
      ]).start();
    };

    const handleKeyboardDidHide = () => {
      setKeyboardOffset(0);
      Animated.parallel([
        Animated.timing(animatedKeyboardOffset, { toValue: 0, duration: KEYBOARD_ANIMATION_DURATION, useNativeDriver: false }),
        Animated.timing(animatedScrollViewMarginBottom, { toValue: baseScrollViewMarginBottom, duration: KEYBOARD_ANIMATION_DURATION, useNativeDriver: false }),
      ]).start();
    };

    const showSubscription = Keyboard.addListener("keyboardDidShow", handleKeyboardDidShow);
    const hideSubscription = Keyboard.addListener("keyboardDidHide", handleKeyboardDidHide);

    return () => {
      showSubscription.remove();
      hideSubscription.remove();
    };
  }, [animatedKeyboardOffset, animatedScrollViewMarginBottom, baseScrollViewMarginBottom]);
  
  const handleScroll = (event: NativeScrollEvent) => {
    if (event.contentOffset.y < 100 && !isLoadingPast) {
      prevContentHeight.current = event.contentSize.height;
      loadPastMessages();
    }
  };

  const handleContentSizeChange = (contentWidth: number, contentHeight: number) => {
    if (shouldMaintainScroll.current && prevContentHeight.current > 0) {
      const heightDiff = contentHeight - prevContentHeight.current;
      scrollViewRef.current?.scrollTo({ y: heightDiff, animated: false });
      shouldMaintainScroll.current = false;
      prevContentHeight.current = 0;
    }
  };

  const hideNotice = () => setShowNotice(false);
  
  const handleSecretMessageParticipate = () => setShowLoveLetterSelect(true);
  
  const handleSecretMessageResultCheck = async () => {
    try {
      const eventTypeForSecretMessageResults = "PICK_MESSAGE";
      const fetchedEvents: RoomEventFromApi[] = await getFilteredRoomEvents(eventTypeForSecretMessageResults);
      
      const messages = fetchedEvents.map(event => String(event.message || "Î©îÏãúÏßÄ ÎÇ¥Ïö©ÏùÑ Î∂àÎü¨Ïò¨ Ïàò ÏóÜÏäµÎãàÎã§."));

      if (messages.length > 0) {
        setReadOnlyEnvelopeMessages(messages);
      } else {
        setReadOnlyEnvelopeMessages(["ÌôïÏù∏Ìï† Ïàò ÏûàÎäî Î©îÏãúÏßÄÍ∞Ä ÏóÜÏäµÎãàÎã§."]);
      }
      setIsEnvelopeReadOnly(true);
      setShowEnvelope(true);
    } catch (error) {
      console.error("ÏãúÌÅ¨Î¶ø Î©îÏãúÏßÄ Í≤∞Í≥º Î°úÎî© Ï§ë Ïò§Î•ò:", error);
      setReadOnlyEnvelopeMessages(["Ïò§Î•ò: Î©îÏãúÏßÄÎ•º Î∂àÎü¨Ïò§Îäî Îç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§."]);
      setIsEnvelopeReadOnly(true);
      setShowEnvelope(true);
    }
  };

  const handleLoveArrowParticipate = () => setShowLoveArrow(true);
  
  const handleLoveArrowResultCheck = () => setShowResultLoveArrow(true);

  const handleFriendArrowResultCheck = () => setShowResultFriendArrow(true);
  
  const handleLoveLetterSelectClose = () => setShowLoveLetterSelect(false);
  
  const handleLoveLetterSelectConfirm = (selectedIndex: number) => {
    setShowLoveLetterSelect(false);
    setShowEnvelope(true);
  };
  
  const handleLoveArrowClose = () => setShowLoveArrow(false);
  
  const handleResultAlertConfirm = () => {
    setShowResultAlertModal(false);
    if (curThemeId === 2) {
      setShowResultFriendArrow(true);
    } else {
      setShowResultLoveArrow(true);
    }
  };
  
  const handleSidebarProfilePress = (nickname: string, SvgComponent: React.FC<SvgProps>) => {
    setSelectedProfile({ nickname, SvgComponent });
  };
  
  const handleEnvelopeAnimationComplete = () => {
    setShowEnvelope(false);
    setIsEnvelopeReadOnly(false);
    setReadOnlyEnvelopeMessages([]);
  };
  
  const handleMatchPress = async () => {
    const currentMemberId = useAuthStore.getState().memberId;
    const participants = useChatRoomStore.getState().chatParts;

    if (!currentMemberId) {
      setShowUnmatchedModal(true);
      return;
    }

    try {
      const events: RoomEventFromApi[] = await getPickEventsForRoom();
      const myEvent = events.find(event => event.senderId === currentMemberId);
      if (!myEvent) {
        setShowUnmatchedModal(true);
        return;
      }

      const partnerEvent = events.find(event => event.senderId === myEvent.receiverId && event.receiverId === currentMemberId);

      if (partnerEvent) {
        const myParticipant = participants.find(p => p.memberId === currentMemberId);
        const partnerParticipant = participants.find(p => p.memberId === myEvent.receiverId);

        if (myParticipant?.nickname && partnerParticipant?.nickname) {
          const mySvg = nicknameToSvgMap[myParticipant.nickname];
          const partnerSvg = nicknameToSvgMap[partnerParticipant.nickname];

          if (mySvg && partnerSvg) {
            const myProfileForMatch: ProfileInfo = { nickname: myParticipant.nickname, SvgComponent: mySvg };
            const partnerProfileForMatch: ProfileInfo = { nickname: partnerParticipant.nickname, SvgComponent: partnerSvg };
            setMatchedPair({ myProfile: myProfileForMatch, partnerProfile: partnerProfileForMatch });
            setShowLoveArrowMatch(true);
          } else {
            setShowUnmatchedModal(true);
          }
        } else {
          setShowUnmatchedModal(true);
        }
      } else {
        setShowUnmatchedModal(true);
      }
    } catch (error) {
      console.error("Îß§Ïπ≠ Í≤∞Í≥º ÌôïÏù∏ Ï§ë Ïò§Î•ò Î∞úÏÉù:", error);
      setShowUnmatchedModal(true);
    }
  };

  const handleToggleSidebar = async () => {
    try {
      await getChatRoomInfo();
    } catch (error) {
      console.error("ÏÇ¨Ïù¥ÎìúÎ∞î Ïó¥Í∏∞ Ï§ë Ï±ÑÌåÖÎ∞© Ï†ïÎ≥¥ Í∞±Ïã† Ïã§Ìå®:", error);
    } finally {
      setSidebarOpen(true);
    }
  };
  
  const getNoticeText = (noticeType: "SECRET_MESSAGE_START" | "SECRET_MESSAGE_RESULT" | "LOVE_ARROW_START" | "LOVE_ARROW_RESULT" | null): string => {
    if (!noticeType) return "[ÏãúÏä§ÌÖú] Í≥µÏßÄÏÇ¨Ìï≠";
    const cupidEventName = curThemeId === 2 ? "Ïö∞Ï†ïÏùò ÏßùÎåÄÍ∏∞" : "ÏÇ¨ÎûëÏùò ÏßùÎåÄÍ∏∞";

    switch (noticeType) {
      case "SECRET_MESSAGE_START":
        return currentEventPhase === "SECRET" ? `[ÏãúÏä§ÌÖú] ÏãúÌÅ¨Î¶ø Î©îÏãúÏßÄ Ïù¥Î≤§Ìä∏ ÏßÑÌñâ Ï§ë! ÏßÄÍ∏à Ï∞∏Ïó¨ÌïòÍ∏∞` : `[ÏãúÏä§ÌÖú] ÏãúÌÅ¨Î¶ø Î©îÏãúÏßÄ Ïù¥Î≤§Ìä∏Í∞Ä Í≥ß ÏãúÏûëÎê©ÎãàÎã§.`;
      case "SECRET_MESSAGE_RESULT":
        return `[ÏãúÏä§ÌÖú] ÏãúÌÅ¨Î¶ø Î©îÏãúÏßÄ Í≤∞Í≥º ÌôïÏù∏ÌïòÍ∏∞ (${cupidEventName} Ïù¥Î≤§Ìä∏Í∞Ä Í≥ß ÏãúÏûëÎê©ÎãàÎã§.)`;
      case "LOVE_ARROW_START":
        return `[ÏãúÏä§ÌÖú] ${cupidEventName} Ïù¥Î≤§Ìä∏ ÏßÑÌñâ Ï§ë! ÏßÄÍ∏à Ï∞∏Ïó¨ÌïòÍ∏∞`;
      case "LOVE_ARROW_RESULT":
        return `[ÏãúÏä§ÌÖú] ${cupidEventName} Í≤∞Í≥º ÌôïÏù∏ÌïòÍ∏∞ (Ï±ÑÌåÖÎ∞©Ïù¥ Í≥ß Ï¢ÖÎ£åÎê©ÎãàÎã§.)`;
      default:
        return "[ÏãúÏä§ÌÖú] ÌòÑÏû¨ ÏßÑÌñâÏ§ëÏù∏ Ïù¥Î≤§Ìä∏Í∞Ä ÏóÜÏäµÎãàÎã§.";
    }
  };
  
  return (
    <View style={styles.container}>
        {sidebarOpen && <BlurView intensity={20} tint="dark" style={[StyleSheet.absoluteFill, { zIndex: 3 }]} />}
        <View style={[styles.headerContainer, { zIndex: sidebarOpen ? 2 : 3 }]}>
          <ChatHeader
            title={themeName || (curThemeId === 2 ? "Îã§Ïù¥Ïä§ ÌîÑÎ†åÏ¶à" : "ÌïòÌä∏ÏãúÍ∑∏ÎÑê")}
            fontColor={curThemeId === 2 ? "#6DA0E1" : "#A45C73"}
            backgroundColor="#ffffff"
            onToggleSidebar={handleToggleSidebar}
          />
          {showNotice && activeNoticeType && (
            <GptNotice 
              text={getNoticeText(activeNoticeType)}
              onHide={hideNotice}
              onParticipate={
                activeNoticeType === "SECRET_MESSAGE_START" ? handleSecretMessageParticipate :
                activeNoticeType === "SECRET_MESSAGE_RESULT" ? handleSecretMessageResultCheck :
                activeNoticeType === "LOVE_ARROW_START" ? handleLoveArrowParticipate :
                activeNoticeType === "LOVE_ARROW_RESULT" ? (curThemeId === 2 ? handleFriendArrowResultCheck : handleLoveArrowResultCheck) :
                () => {}
              }
              hideOnParticipate={false}
            />
          )}
        </View>
        <Animated.ScrollView 
          ref={scrollViewRef}
          style={[styles.scrollViewBase, { marginTop: scrollViewMarginTop, marginBottom: animatedScrollViewMarginBottom }]}
          contentContainerStyle={styles.scrollContent}
          showsVerticalScrollIndicator={false}
          keyboardShouldPersistTaps="handled"
          onScroll={(e) => handleScroll(e.nativeEvent)}
          onContentSizeChange={handleContentSizeChange}
          scrollEventThrottle={16}
        >
          {isLoadingPast && <ActivityIndicator style={{ marginVertical: 20 }} size="small" color="#B28EF8" />}
          {messages.map((msg, index) => {
            const isMine = Number(msg.memberId) === Number(useAuthStore.getState().memberId);
            
            let isoCreatedAt = msg.createdAt.replace(' ', 'T');
            if (!isoCreatedAt.endsWith('Z') && !isoCreatedAt.match(/[+-]\d{2}:\d{2}$/)) {
              isoCreatedAt += 'Z';
            }
            const timeFormatted = new Date(isoCreatedAt).toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
            const ProfileSvg = nicknameToSvgMap[msg.nickname] || NemoSvg;

            const messageComponent = isMine ? (
              <ChatMessageRight
                profileImage={ProfileSvg} nickname={msg.nickname} message={msg.message} time={timeFormatted}
                isConsecutive={index > 0 && messages[index - 1].memberId === msg.memberId}
                showTime={true} onPressProfile={() => setSelectedProfile({ nickname: msg.nickname, SvgComponent: ProfileSvg })}
              />
            ) : (
              <ChatMessageLeft
                profileImage={ProfileSvg} nickname={msg.nickname} message={msg.message} time={timeFormatted}
                isConsecutive={index > 0 && messages[index - 1].memberId === msg.memberId}
                showTime={true} onPressProfile={() => setSelectedProfile({ nickname: msg.nickname, SvgComponent: ProfileSvg })}
              />
            );
            
            return (
              <React.Fragment key={msg.chatId}>
                {Number(msg.chatId) === fixedReadingTagAtMessageId && <ReadingTag />}
                {messageComponent}
              </React.Fragment>
            );
          })}
        </Animated.ScrollView>
        <SideBar visible={sidebarOpen} onClose={() => setSidebarOpen(false)} onProfilePress={handleSidebarProfilePress} />
        <Animated.View style={[styles.inputContainer, { bottom: animatedKeyboardOffset }]}>
          <ChatInput onSendMessage={sendMessage} />
        </Animated.View>
        {selectedProfile && (
          <View style={styles.profileOverlay}>
            <ChatProfile profileImage={selectedProfile.SvgComponent} nickname={selectedProfile.nickname} onClose={() => setSelectedProfile(null)} />
          </View>
        )}
        <LoveLetterSelect visible={showLoveLetterSelect} onClose={handleLoveLetterSelectClose} onConfirm={handleLoveLetterSelectConfirm} />
        <LoveArrow visible={showLoveArrow} onClose={handleLoveArrowClose} remainingCount={1} />
        <Modal visible={showResultAlertModal} transparent={true} animationType="fade" onRequestClose={() => setShowResultAlertModal(false)}>
          <View style={styles.modalContainer}>
            <View style={styles.alertModalContent}>
              <Text style={[styles.alertModalTitle, { color: alertModalTitleColor }]}>Îß§Ïπ≠ Í≤∞Í≥º ÌôïÏù∏</Text>
              <Text style={[styles.alertModalText, { color: alertModalTitleColor }]}>Îß§Ïπ≠ Í≤∞Í≥ºÎ•º ÌôïÏù∏ÌïòÏãúÍ≤†ÏäµÎãàÍπå?</Text>
              <View style={styles.alertModalButtons}>
                <TouchableOpacity style={[styles.alertModalButton, styles.alertModalCancelButton]} onPress={() => setShowResultAlertModal(false)}>
                  <Text style={styles.alertModalButtonText}>Ï∑®ÏÜå</Text>
                </TouchableOpacity>
                <TouchableOpacity style={[styles.alertModalButton, styles.alertModalConfirmButton, { backgroundColor: alertModalConfirmButtonColor }]} onPress={handleResultAlertConfirm}>
                  <Text style={styles.alertModalButtonText}>ÌôïÏù∏</Text>
                </TouchableOpacity>
              </View>
            </View>
          </View>
        </Modal>
        <Modal visible={showResultLoveArrow} transparent={true} animationType="fade" onRequestClose={() => setShowResultLoveArrow(false)}>
          <View style={styles.modalContainer}>
              <ResultLoveArrow onMatchPress={handleMatchPress} onClose={() => setShowResultLoveArrow(false)} themeId={curThemeId} />
          </View>
        </Modal>
        <Modal visible={showResultFriendArrow} transparent={true} animationType="fade" onRequestClose={() => setShowResultFriendArrow(false)}>
          <View style={styles.modalContainer}>
            <ResultFriendArrow onMatchPress={handleMatchPress} onClose={() => setShowResultFriendArrow(false)} />
          </View>
        </Modal>
        {showEnvelope && (
          <View style={styles.envelopeOverlay}>
            <EnvelopeAnimation autoPlay={true} onAnimationComplete={handleEnvelopeAnimationComplete} isReadOnly={isEnvelopeReadOnly} messages={readOnlyEnvelopeMessages}
              content={
                <View style={styles.envelopeContent}>
                  <Text style={styles.envelopeTitle}>ÌÅêÌîºÌä∏Ïùò ÏßùÎåÄÍ∏∞ Ïù¥Î≤§Ìä∏</Text>
                  <TouchableOpacity style={styles.envelopeButton} onPress={() => setShowEnvelope(false)}>
                    <Text style={styles.envelopeButtonText}>ÌôïÏù∏</Text>
                  </TouchableOpacity>
                </View>
              }
            />
          </View>
        )}
        {showLoveArrowMatch && matchedPair?.myProfile && matchedPair?.partnerProfile && (
          <LoveArrowMatch isVisible={showLoveArrowMatch} onClose={() => { setShowLoveArrowMatch(false); setMatchedPair(null); }} myProfile={matchedPair.myProfile} partnerProfile={matchedPair.partnerProfile} />
        )}
        <UnmatchedModal visible={showUnmatchedModal} onClose={() => setShowUnmatchedModal(false)} />
    </View>
  );
};

export default ChatRoom;

const styles = StyleSheet.create({
  container: { flex: 1, backgroundColor: "#fff" },
  headerContainer: { position: 'absolute', top: 0, left: 0, right: 0, zIndex: 2, backgroundColor: '#fff' },
  scrollViewBase: { flex: 1 },
  scrollContent: { paddingHorizontal: SCREEN_WIDTH * 0.025, paddingBottom: SCREEN_HEIGHT * 0.05 },
  inputContainer: { position: 'absolute', bottom: 0, left: 0, right: 0, height: SCREEN_HEIGHT * 0.07, backgroundColor: "#ffffff" },
  profileOverlay: { position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, backgroundColor: 'rgba(0, 0, 0, 0.5)', justifyContent: 'center', alignItems: 'center', zIndex: 9999, elevation: 5 },
  envelopeOverlay: { position: 'absolute', top: 0, left: 0, right: 0, bottom: 0, backgroundColor: 'rgba(0, 0, 0, 0.7)', justifyContent: 'center', alignItems: 'center', zIndex: 9999, elevation: 5 },
  envelopeContent: { flex: 1, padding: 10, justifyContent: 'center', alignItems: 'center' },
  envelopeTitle: { fontSize: 20, fontWeight: 'bold', color: '#A45C73', marginBottom: 20, textAlign: 'center' },
  envelopeButton: { backgroundColor: '#A45C73', paddingVertical: 10, paddingHorizontal: 25, borderRadius: 20, marginTop: 15 },
  envelopeButtonText: { color: 'white', fontSize: 16, fontWeight: '500' },
  modalContainer: { flex: 1, justifyContent: 'center', alignItems: 'center', backgroundColor: 'rgba(0, 0, 0, 0.5)' },
  alertModalContent: { backgroundColor: 'white', borderRadius: 20, padding: 20, width: '80%', alignItems: 'center', shadowColor: '#000', shadowOffset: { width: 0, height: 2 }, shadowOpacity: 0.25, shadowRadius: 3.84, elevation: 5 },
  alertModalTitle: { fontSize: 18, fontWeight: 'bold', marginBottom: 15 },
  alertModalText: { fontSize: 16, marginBottom: 20, textAlign: 'center' },
  alertModalButtons: { flexDirection: 'row', justifyContent: 'space-between', width: '100%', paddingHorizontal: 20 },
  alertModalButton: { paddingVertical: 10, paddingHorizontal: 30, borderRadius: 25, minWidth: 100, alignItems: 'center' },
  alertModalCancelButton: { backgroundColor: '#DDDDDD', marginRight: 10 },
  alertModalConfirmButton: {},
  alertModalButtonText: { color: '#FFFFFF', fontSize: 16, fontWeight: '500' },
});
